# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2026 Quant Civil
"""
/***************************************************************************
 Segmenter
                     A QGIS plugin
 This plugin segments the map into discrete buckets
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                  -------------------
     begin                : 2023-05-26
     git sha              : $Format:%H$
     copyright            : (C) 2023 by Quant Civil
     email                : joshua.herrera@quantcivil.ai
 ***************************************************************************/
"""
from __future__ import annotations

from collections import deque
from datetime import datetime
import os
import re
import weakref
from typing import Optional, TYPE_CHECKING

import numpy as np

try:  # Import QGIS/Qt lazily so the module can be imported without QGIS
    from qgis.PyQt.QtCore import (  # type: ignore
        QCoreApplication,
        QEvent,
        QObject,
        QSettings,
        Qt,
        QThread,
        QTranslator,
        QUrl,
        pyqtSignal,
    )
    from qgis.PyQt.QtGui import QDesktopServices, QIcon, QPixmap  # type: ignore
    from qgis.PyQt.QtWidgets import QAction, QMessageBox  # type: ignore
    from qgis.core import Qgis, QgsApplication, QgsMessageLog, QgsProject, QgsRasterLayer, QgsTask  # type: ignore
    _HAS_QGIS = True
except Exception:  # pragma: no cover - QGIS not installed in default test envs
    _HAS_QGIS = False

if TYPE_CHECKING:  # pragma: no cover - type hints only
    from qgis.gui import QgsInterface  # type: ignore

if not _HAS_QGIS:  # pragma: no cover - optional runtime stubs for tests
    class _Stub:
        def __init__(self, *args, **kwargs):
            pass

        def __call__(self, *args, **kwargs):  # allow callable behaviors
            return None

        def __getattr__(self, _):
            return _Stub()

    class QObject(_Stub):
        pass

    class QEvent:
        MouseButtonPress = object()
        FocusIn = object()

    class QCoreApplication:  # type: ignore
        @staticmethod
        def translate(_context, message):
            return message

        @staticmethod
        def installTranslator(_):
            return None

    class QSettings(_Stub):
        def value(self, *_args, **_kwargs):
            return ""

        def setValue(self, *_args, **_kwargs):
            return None

    class Qt:
        WA_Hover = 0

    class QThread(_Stub):
        @staticmethod
        def idealThreadCount():
            return 1

    class QTranslator(_Stub):
        pass

    class QUrl(_Stub):
        def __init__(self, url: str = ""):
            super().__init__()
            self.url = url

    def pyqtSignal(*_args, **_kwargs):  # type: ignore
        return _Stub()

    class QDesktopServices:
        @staticmethod
        def openUrl(_):
            return False

    class QIcon(_Stub):
        def __init__(self, *_args, **_kwargs):
            super().__init__()

    class QPixmap(_Stub):
        def setPixmap(self, *_args, **_kwargs):
            return None

    class QAction(_Stub):
        def __init__(self, *args, **kwargs):
            super().__init__()

        def triggered(self, *_args, **_kwargs):
            return _Stub()

        def setEnabled(self, *_args, **_kwargs):
            return None

        def setStatusTip(self, *_args, **_kwargs):
            return None

        def setWhatsThis(self, *_args, **_kwargs):
            return None

    class QMessageBox:
        @staticmethod
        def warning(*_args, **_kwargs):
            return None

    class Qgis:
        Info = "Info"
        Critical = "Critical"

    class QgsMessageLog:
        @staticmethod
        def logMessage(*_args, **_kwargs):
            return None

    class _StubTaskManager:
        def addTask(self, *_args, **_kwargs):
            return None

        def cancelTask(self, *_args, **_kwargs):
            return None

    class QgsApplication:
        @staticmethod
        def taskManager():
            return _StubTaskManager()

        @staticmethod
        def setMaxThreads(_count):
            return None

    class QgsProject:
        @staticmethod
        def instance():
            return QgsProject()

        def mapLayersByName(self, *_args, **_kwargs):
            return []

        def mapLayers(self):
            return {}

    class QgsRasterLayer(_Stub):
        pass

    class QgsTask(_Stub):
        def isCanceled(self):
            return False

        def taskId(self):
            return None

        def cancel(self):
            return False

    def render_raster(*_args, **_kwargs):  # type: ignore
        raise ImportError("QGIS runtime is required to render rasters.")

    class SegmenterDialog(_Stub):
        def __init__(self, *args, **kwargs):
            super().__init__()

else:
    from .qgis_funcs import render_raster
    from .segmenter_dialog import SegmenterDialog

from .funcs import SegmentationCanceled, predict_nextgen_numpy
from .model import load_runtime

SUPPORTED_RASTER_EXTENSIONS = {".tif", ".tiff"}
TILE_SIZE = 256
PROGRESS_TEXT_LIMIT = 120
PROGRESS_PERCENT_PATTERN = re.compile(r"(?P<percent>\d{1,3})%")
PROGRESS_STEP_PATTERN = re.compile(r"(?P<current>\d+)\s*/\s*(?P<total>\d+)")
PROGRESS_STAGE_MAP = {
    "prepare": (0, 25, "Preparing segmentation..."),
    "queue": (25, 35, "Queuing task..."),
    "chunk_plan": (35, 40, "Planning chunks..."),
    "inference": (40, 90, "Running segmentation..."),
    "latent": (60, 92, "Refining labels..."),
    "smooth": (92, 96, "Smoothing map..."),
    "render": (96, 100, "Rendering output..."),
}
GITHUB_ISSUES_URL = "https://github.com/sirebellum/qgis-segmentation/issues"
BUY_ME_A_COFFEE_URL = "https://www.buymeacoffee.com/quantcivil"


class CancellationToken:
    def __init__(self):
        self._cancelled = False
        self._task_ref = None

    def cancel(self):
        self._cancelled = True
        task = self._task_ref() if self._task_ref else None
        if task and hasattr(task, "cancel"):
            try:
                task.cancel()
            except Exception:
                pass

    def is_cancelled(self):
        return bool(self._cancelled)

    def raise_if_cancelled(self):
        if self._cancelled:
            raise SegmentationCanceled()

    def bind_task(self, task):
        try:
            self._task_ref = weakref.ref(task)
        except Exception:
            self._task_ref = None


class StatusEmitter(QObject):
    message = pyqtSignal(tuple)


class _ComboRefreshController(QObject):
    def __init__(self, combo, callback):
        super().__init__(combo)
        self._combo = combo
        self._callback = callback

    def eventFilter(self, obj, event):  # pragma: no cover - UI glue
        if obj is self._combo and event.type() in {QEvent.MouseButtonPress, QEvent.FocusIn}:
            if callable(self._callback):
                try:
                    self._callback()
                except Exception:
                    pass
        return False


class _LogoHoverController(QObject):
    def __init__(self, widget, callback):
        super().__init__(widget)
        self._widget = widget
        self._callback = callback

    def eventFilter(self, obj, event):  # pragma: no cover - UI glue
        if obj is self._widget and event.type() == QEvent.MouseButtonPress:
            if callable(self._callback):
                try:
                    self._callback()
                except Exception:
                    pass
            return True
        return False


# Multithreading stuff
class Task(QgsTask):
    def __init__(self, function, *args, **kwargs):
        super().__init__()
        self.function = function
        self.args = args
        cancel_token = kwargs.pop("cancel_token", None)
        self.cancel_token = cancel_token or CancellationToken()
        self.cancel_token.bind_task(self)
        self.kwargs = kwargs
        self.result = None
        QgsMessageLog.logMessage("Task initialized", "Segmenter", level=Qgis.Info)
        self._status("Task queued")

    def run(self):
        QgsMessageLog.logMessage("Running task", "Segmenter", level=Qgis.Info)
        self._status("Processing started")
        if self.isCanceled():
            self._status("Task canceled before execution")
            return False
        try:
            self.result = self.function(*self.args, cancel_token=self.cancel_token)
            if self.isCanceled():
                self._status("Processing canceled")
                return False
            self._status("Processing completed successfully")
            return True
        except SegmentationCanceled:
            self._status("Processing canceled")
            return False
        except Exception as e:
            QgsMessageLog.logMessage(
                f"Exception in task: {e}", "Segmenter", level=Qgis.Critical
            )
            self._status(f"Processing failed: {e}")
            return False

    def cancel(self):
        self.cancel_token.cancel()
        return super().cancel()

    def finished(self, result):
        QgsMessageLog.logMessage("Task finished", "Segmenter", level=Qgis.Info)
        segmenter = self.kwargs.get("segmenter")
        if result and not self.isCanceled():
            # render raster
            if segmenter:
                segmenter._update_overall_progress("render", 20, "Rendering output...")
            render_raster(
                self.result,
                self.kwargs["layer"].extent(),
                f"{self.kwargs['layer'].name()}_{self.kwargs['model']}_{self.kwargs['num_segments']}",
                self.kwargs["canvas"].layer(0).crs().postgisSrid(),
            )
            self._status("Segmentation layer rendered")
        elif self.isCanceled():
            self._status("Segmentation task canceled")
        else:
            self._status("Segmentation task failed")
        if segmenter:
            segmenter.task = None
            segmenter._set_stop_enabled(False)
            if result and not self.isCanceled():
                segmenter._finalize_progress("success")
            elif self.isCanceled():
                segmenter._finalize_progress("canceled")
            else:
                segmenter._finalize_progress("error")

    def _status(self, message):
        callback = self.kwargs.get("status_callback")
        if not callback:
            return
        try:
            callback(message)
        except Exception:  # pragma: no cover - best effort status callback
            pass


def run_task(function, *args, **kwargs):
    task = Task(function, *args, **kwargs)
    QgsApplication.taskManager().addTask(task)
    return task


class Segmenter:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        if not _HAS_QGIS:
            raise ImportError("Segmenter requires QGIS runtime; QGIS bindings were not detected.")
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "Segmenter_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&Map Segmenter")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        QSettings().setValue("/qgis/parallel_rendering", True)
        threadcount = QThread.idealThreadCount()
        QgsApplication.setMaxThreads(threadcount)

        self.task = None
        self._status_buffer = []
        self._log_history = deque(maxlen=50)
        self.status_emitter = StatusEmitter()
        self.status_emitter.message.connect(self._handle_status_message)
        self._logged_missing_layers = False
        self._logo_hover = None
        self._layer_refresh_controller = None
        self._progress_last_value = 0.0
        self._progress_active = False
        self._progress_stage = "idle"
        self.nextgen_model_dir = os.path.join(self.plugin_dir, "model", "best")

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("Segmenter", message)

    def log_status(self, message):
        self._emit_status_message(message, category="general")

    def worker_status(self, message):
        self._emit_status_message(message, category="worker")

    def _emit_status_message(self, message, category):
        self.status_emitter.message.emit((category, message))

    def _handle_status_message(self, payload):
        category, message = payload
        timestamp = datetime.now().strftime("%H:%M:%S")
        entry = f"[{timestamp}] {message}"
        if getattr(self, "dlg", None):
            if self._should_display_log(category, message):
                self._append_log_entry(entry)
            self._maybe_update_progress_from_message(category, message)
        else:
            self._status_buffer.append((category, message, timestamp))

    def _flush_status_buffer(self):
        if not getattr(self, "dlg", None):
            return
        while self._status_buffer:
            category, message, timestamp = self._status_buffer.pop(0)
            entry = f"[{timestamp}] {message}"
            if self._should_display_log(category, message):
                self._append_log_entry(entry)

    def _should_display_log(self, category, message):
        if category == "general":
            return True
        if category == "worker":
            return bool(re.search(r"\b\d+\s*/\s*\d+\b", message))
        return False

    def _append_log_entry(self, entry):
        self._log_history.append(entry)
        if getattr(self, "dlg", None):
            lines = list(self._log_history)[::-1]
            self.dlg.inputBox.setPlainText("\n".join(lines))

    def _progress_widget(self):
        dlg = getattr(self, "dlg", None)
        if not dlg:
            return None
        return getattr(dlg, "jobProgress", None)

    def _reset_progress_bar(self, text="Idle"):
        self._progress_last_value = 0.0
        self._progress_active = False
        self._progress_stage = "idle"
        bar = self._progress_widget()
        if not bar:
            return
        bar.setRange(0, 100)
        bar.setValue(0)
        bar.setFormat(text)

    def _start_progress_cycle(self, message="Preparing segmentation..."):
        self._progress_active = True
        self._update_overall_progress("prepare", 0, message)

    def _update_overall_progress(self, stage: str, local_percent: float = 0.0, message: Optional[str] = None):
        info = PROGRESS_STAGE_MAP.get(stage)
        if not info:
            return
        start, end, default_text = info
        span = max(end - start, 1e-6)
        normalized = float(np.clip(local_percent, 0.0, 100.0)) / 100.0
        value = start + span * normalized
        self._progress_stage = stage
        self._apply_progress_update(value, message or default_text)

    def _apply_progress_update(self, percent, message=None):
        bar = self._progress_widget()
        if not bar:
            return
        self._progress_active = True
        bar.setRange(0, 100)
        value = float(np.clip(percent, 0.0, 100.0))
        if value < self._progress_last_value:
            value = self._progress_last_value
        self._progress_last_value = value
        bar.setValue(int(round(value)))
        if message:
            bar.setFormat(self._format_progress_text(message))

    def _format_progress_text(self, message):
        cleaned = (message or "").strip()
        if not cleaned:
            return "Working..."
        if len(cleaned) > PROGRESS_TEXT_LIMIT:
            return cleaned[: PROGRESS_TEXT_LIMIT - 3] + "..."
        return cleaned

    def _set_progress_message(self, message, indeterminate=False):
        bar = self._progress_widget()
        if not bar or not message:
            return
        if indeterminate:
            bar.setRange(0, 0)
        elif bar.maximum() == 0:
            bar.setRange(0, 100)
        bar.setFormat(self._format_progress_text(message))

    def _finalize_progress(self, status="idle"):
        bar = self._progress_widget()
        if not bar:
            return
        self._progress_active = False
        bar.setRange(0, 100)
        if status == "success":
            self._update_overall_progress("render", 100, "Segmentation complete")
        elif status == "canceled":
            bar.setValue(int(round(self._progress_last_value)))
            bar.setFormat("Canceled")
        elif status == "error":
            value = self._progress_last_value if self._progress_last_value > 0 else 0
            bar.setValue(int(round(value)))
            bar.setFormat("Failed")
        else:
            self._reset_progress_bar()
            return
        if status in {"success", "canceled", "error"}:
            self._progress_stage = "idle"

    def _maybe_update_progress_from_message(self, category, message):
        if category not in {"worker", "general"}:
            return
        stage, percent = self._extract_progress_hint(message)
        if stage is None or percent is None:
            return
        self._update_overall_progress(stage, percent, message)

    def _extract_progress_hint(self, message):
        if not message:
            return None, None
        normalized = message.lower()
        percent = self._extract_percent_token(message)
        if percent is None:
            percent = self._extract_step_percent(message)
        if percent is None:
            return None, None
        stage = None
        if "latent" in normalized or "knn" in normalized:
            stage = "latent"
        elif "smooth" in normalized or "blur" in normalized:
            stage = "smooth"
        elif "render" in normalized:
            stage = "render"
        elif "prepare" in normalized:
            stage = "prepare"
        elif "chunk" in normalized and "plan" in normalized:
            stage = "chunk_plan"
        elif "queue" in normalized:
            stage = "queue"
        else:
            stage = "inference"
        return stage, percent

    def _extract_percent_token(self, message):
        match = PROGRESS_PERCENT_PATTERN.search(message)
        if not match:
            return None
        try:
            value = int(match.group("percent"))
        except (TypeError, ValueError):
            return None
        return int(np.clip(value, 0, 100))

    def _extract_step_percent(self, message):
        match = PROGRESS_STEP_PATTERN.search(message)
        if not match:
            return None
        try:
            current = int(match.group("current"))
            total = int(match.group("total"))
        except (TypeError, ValueError):
            return None
        if total <= 0:
            return None
        ratio = max(0.0, min(1.0, current / total))
        return int(round(ratio * 100))

    def _set_stop_enabled(self, enabled):
        dlg = getattr(self, "dlg", None)
        if not dlg:
            return
        button = getattr(dlg, "buttonStop", None)
        if button is not None:
            button.setEnabled(bool(enabled))

    # Legacy heuristic hooks removed; next-gen runtime does not expose tuning sliders.

    def open_feedback_link(self):
        if not getattr(self, "dlg", None):
            return
        opened = QDesktopServices.openUrl(QUrl(GITHUB_ISSUES_URL))
        if opened:
            self.log_status(f"Opening feedback page: {GITHUB_ISSUES_URL}")
        else:
            QMessageBox.warning(
                self.dlg,
                "Unable to open link",
                "Could not launch the browser. Please visit the issues page manually.",
            )

    def _open_support_link(self):
        if not getattr(self, "dlg", None):
            return
        opened = QDesktopServices.openUrl(QUrl(BUY_ME_A_COFFEE_URL))
        if opened:
            self.log_status("Thanks for considering supporting development!")
        else:
            QMessageBox.warning(
                self.dlg,
                "Unable to open link",
                "Could not launch the browser. Please try again later.",
            )

    def stop_current_task(self):
        if not self.task:
            self.log_status("No active segmentation task to cancel.")
            return
        if self.task.isCanceled():
            self.log_status("Cancellation already requested.")
            return
        try:
            task_id = self.task.taskId()
        except AttributeError:
            task_id = None
        if task_id is not None:
            QgsApplication.taskManager().cancelTask(task_id)
        self.task.cancel()
        self._set_stop_enabled(False)
        self._set_progress_message("Cancelling task...")
        self.log_status("Cancellation requested; attempting to stop the worker immediately.")

    def _init_logo_interactions(self):
        logo = getattr(self.dlg, "imageLarge", None)
        if not logo:
            return
        logo.setAttribute(Qt.WA_Hover, True)
        logo.setMouseTracking(True)
        if self._logo_hover is None:
            self._logo_hover = _LogoHoverController(logo, self._open_support_link)
            logo.installEventFilter(self._logo_hover)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/segmenter/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("Segment the map"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&Map Segmenter"), action)
            self.iface.removeToolBarIcon(action)

    # Predict coverage map
    def predict(self):
        self._start_progress_cycle("Preparing segmentation...")
        self._update_overall_progress("prepare", 10, "Validating layer selection...")

        layer_name = self.dlg.inputLayer.currentText()
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if not layers:
            self.log_status("Selected layer is no longer available. Please choose another layer.")
            self._reset_progress_bar()
            return
        layer = layers[0]
        supported, reason = self._is_supported_raster_layer(layer)
        if not supported:
            self.log_status(f"Selected layer is not supported: {reason}")
            self._reset_progress_bar()
            return
        assert layer.isValid(), f"Invalid raster layer! \n{layer_name}"
        raster_source = layer.source().split("|")[0]
        self._update_overall_progress("prepare", 60, "Raster scheduled for background loading.")
        self.log_status("Raster IO deferred to the worker thread to keep QGIS responsive.")

        segments_raw = (self.dlg.inputSegments.text() or "").strip()
        if not segments_raw:
            self.log_status("Please enter the desired number of segments and try again.")
            self.dlg.inputSegments.setFocus()
            self._reset_progress_bar()
            return
        try:
            num_segments = int(segments_raw)
        except ValueError:
            self.log_status("Number of segments must be an integer value.")
            self.dlg.inputSegments.setFocus()
            self._reset_progress_bar()
            return
        if num_segments <= 0:
            self.log_status("Number of segments must be a positive integer.")
            self.dlg.inputSegments.setFocus()
            self._reset_progress_bar()
            return

        model_dir = self.nextgen_model_dir
        if not os.path.isdir(model_dir):
            self.log_status(
                f"Next-gen model artifacts not found at {model_dir}. Run training export to generate meta.json and model.npz."
            )
            self._reset_progress_bar()
            return

        kwargs = {
            "layer": layer,
            "canvas": self.canvas,
            "dlg": self.dlg,
            "model": "nextgen",
            "num_segments": num_segments,
            "status_callback": self.log_status,
            "segmenter": self,
        }

        func = predict_nextgen_numpy
        model_provider = lambda: self.load_nextgen_runtime(model_dir)
        args = (
            model_provider,
            raster_source,
            num_segments,
            TILE_SIZE,
            self.worker_status,
        )

        self._update_overall_progress("queue", 90, "Dispatching segmentation task...")
        self.log_status(
            f"Queued NEXTGEN segmentation with {num_segments} segments."
        )
        self._update_overall_progress("queue", 100, "Task queued; starting worker...")
        self._update_overall_progress("inference", 0, "Running segmentation...")
        self.task = run_task(func, *args, **kwargs)
        self._set_stop_enabled(True)

        if self.task.waitForFinished(1):
            self.log_status("An error occurred. Please try again.")

    def load_nextgen_runtime(self, model_dir: Optional[str] = None):
        target = model_dir or self.nextgen_model_dir
        try:
            backend_pref = os.environ.get("SEGMENTER_RUNTIME_BACKEND", "auto")
            device_pref = os.environ.get("SEGMENTER_DEVICE", "auto")
            return load_runtime(
                target,
                prefer=backend_pref,
                device_preference=device_pref,
                status_callback=self.log_status,
            )
        except FileNotFoundError as exc:
            self.log_status(str(exc))
            raise

    # Process user input box
    def submit(self):
        return

    # Display layers in dropdown
    def render_layers(self):
        project_layers = QgsProject.instance().mapLayers().values()
        raster_layers = []
        for layer in project_layers:
            ok, _ = self._is_supported_raster_layer(layer)
            if isinstance(layer, QgsRasterLayer) and ok:
                raster_layers.append(layer)
        raster_layers.sort(key=lambda lyr: lyr.name().lower())

        current = self.dlg.inputLayer.currentText()
        self.dlg.inputLayer.clear()
        if not raster_layers:
            if not self._logged_missing_layers:
                self.log_status("No supported 3-band GeoTIFF rasters detected in the project.")
                self._logged_missing_layers = True
            return

        self._logged_missing_layers = False
        for layer in raster_layers:
            self.dlg.inputLayer.addItem(layer.name())

        if current:
            index = self.dlg.inputLayer.findText(current)
            if index >= 0:
                self.dlg.inputLayer.setCurrentIndex(index)

    def _is_supported_raster_layer(self, layer):
        if not isinstance(layer, QgsRasterLayer):
            return False, "Layer is not a raster layer."
        try:
            band_count = layer.bandCount()
        except Exception:
            return False, "Unable to read raster band count."
        if band_count != 3:
            return False, f"Layer has {band_count} band(s); requires exactly 3."
        provider = layer.dataProvider()
        if not provider:
            return False, "Layer has no data provider."
        if provider.name().lower() != "gdal":
            return False, f"Layer provider must be GDAL; found {provider.name()}."
        source = layer.source().split("|")[0]
        _, ext = os.path.splitext(source)
        if ext.lower() not in SUPPORTED_RASTER_EXTENSIONS:
            return False, f"Layer source must be a GeoTIFF (.tif/.tiff); found extension '{ext or 'unknown'}'."
        return True, ""

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = SegmenterDialog()
            self.canvas = self.iface.mapCanvas()
            self._reset_progress_bar()

            # Populate drop down menus
            self.render_layers()
            if not (self.dlg.inputSegments.text() or "").strip():
                self.dlg.inputSegments.setText("8")

            self._log_history.clear()
            self.dlg.inputBox.clear()
            self._flush_status_buffer()
            self.log_status("Next-gen numpy runtime active (single-model path).")

            # Attach inputs
            self.dlg.inputBox.textChanged.connect(self.submit)
            self.dlg.buttonPredict.clicked.connect(self.predict)
            self.dlg.buttonFeedback.clicked.connect(self.open_feedback_link)
            self.dlg.buttonStop.clicked.connect(self.stop_current_task)
            self._set_stop_enabled(False)

            # Render logo
            img_path = os.path.join(self.plugin_dir, "logo.png")
            pix = QPixmap(img_path)
            self.dlg.imageLarge.setPixmap(pix)
            self._init_logo_interactions()
            self._init_layer_refresh()

        # show the dialog
        self.render_layers()
        if not self.task:
            self._reset_progress_bar()
        self.dlg.show()

    def _init_layer_refresh(self):
        dlg = getattr(self, "dlg", None)
        if not dlg:
            return
        combo = getattr(dlg, "inputLayer", None)
        if not combo:
            return
        if self._layer_refresh_controller is None:
            self._layer_refresh_controller = _ComboRefreshController(combo, self.render_layers)
            combo.installEventFilter(self._layer_refresh_controller)

    # Profiling hooks removed; next-gen runtime is numpy-only.
