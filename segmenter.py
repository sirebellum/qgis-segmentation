"""
/***************************************************************************
 Segmenter
                     A QGIS plugin
 This plugin segments the map into discrete buckets
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                  -------------------
     begin                : 2023-05-26
     git sha              : $Format:%H$
     copyright            : (C) 2023 by Quant Civil
     email                : joshua.herrera@quantcivil.ai
 ***************************************************************************/
"""
from collections import deque
import os
import re
import threading
import weakref
from typing import Optional
from qgis.PyQt.QtCore import (
    QSettings,
    QTranslator,
    QCoreApplication,
    QThread,
    QObject,
    pyqtSignal,
    QUrl,
)
from qgis.PyQt.QtGui import QIcon, QPixmap, QDesktopServices
from qgis.PyQt.QtWidgets import (
    QAction,
    QMessageBox,
)
from qgis.core import (
    QgsTask,
    QgsApplication,
    QgsMessageLog,
    QgsProject,
    QgsRasterLayer,
    Qgis,
)

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .segmenter_dialog import SegmenterDialog

from io import BytesIO
from datetime import datetime
from osgeo import gdal

from .dependency_manager import ensure_dependencies

ensure_dependencies()

import torch
from sklearn.cluster import KMeans
import numpy as np
from .autoencoder_utils import TextureAutoencoderManager, default_autoencoder_path

from .funcs import (
    recommended_chunk_plan,
    execute_kmeans_segmentation,
    execute_cnn_segmentation,
    SegmentationCanceled,
)
from .perf_tuner import load_or_profile_settings
from .qgis_funcs import render_raster

TILE_SIZE = 512
SUPPORTED_RASTER_EXTENSIONS = {".tif", ".tiff"}
GITHUB_ISSUES_URL = "https://github.com/sirebellum/qgis-segmentation/issues/new/choose"


class StatusEmitter(QObject):
    message = pyqtSignal(object)


class CancellationToken:
    def __init__(self):
        self._event = threading.Event()
        self._task_ref: Optional[weakref.ReferenceType] = None

    def bind_task(self, task: QgsTask) -> None:
        try:
            self._task_ref = weakref.ref(task)
        except TypeError:
            self._task_ref = None

    def cancel(self) -> None:
        self._event.set()

    def is_cancelled(self) -> bool:
        if self._event.is_set():
            return True
        if self._task_ref is None:
            return False
        task = self._task_ref()
        if task is not None and task.isCanceled():
            self._event.set()
            return True
        return self._event.is_set()

    def raise_if_cancelled(self) -> None:
        if self.is_cancelled():
            raise SegmentationCanceled()


# Multithreading stuff
class Task(QgsTask):
    def __init__(self, function, *args, **kwargs):
        super().__init__()
        self.function = function
        self.args = args
        cancel_token = kwargs.pop("cancel_token", None)
        self.cancel_token = cancel_token or CancellationToken()
        self.cancel_token.bind_task(self)
        self.kwargs = kwargs
        self.result = None
        QgsMessageLog.logMessage("Task initialized", "Segmenter", level=Qgis.Info)
        self._status("Task queued")

    def run(self):
        QgsMessageLog.logMessage("Running task", "Segmenter", level=Qgis.Info)
        self._status("Processing started")
        if self.isCanceled():
            self._status("Task canceled before execution")
            return False
        try:
            self.result = self.function(*self.args, cancel_token=self.cancel_token)
            if self.isCanceled():
                self._status("Processing canceled")
                return False
            self._status("Processing completed successfully")
            return True
        except SegmentationCanceled:
            self._status("Processing canceled")
            return False
        except Exception as e:
            QgsMessageLog.logMessage(
                f"Exception in task: {e}", "Segmenter", level=Qgis.Critical
            )
            self._status(f"Processing failed: {e}")
            return False

    def cancel(self):
        self.cancel_token.cancel()
        return super().cancel()

    def finished(self, result):
        QgsMessageLog.logMessage("Task finished", "Segmenter", level=Qgis.Info)
        segmenter = self.kwargs.get("segmenter")
        if result and not self.isCanceled():
            # render raster
            render_raster(
                self.result,
                self.kwargs["layer"].extent(),
                f"{self.kwargs['layer'].name()}_{self.kwargs['model']}_{self.kwargs['num_segments']}_{self.kwargs['resolution']}",
                self.kwargs["canvas"].layer(0).crs().postgisSrid(),
            )
            self._status("Segmentation layer rendered")
        elif self.isCanceled():
            self._status("Segmentation task canceled")
        else:
            self._status("Segmentation task failed")
        if segmenter:
            segmenter.task = None
            segmenter._set_stop_enabled(False)

    def _status(self, message):
        callback = self.kwargs.get("status_callback")
        if not callback:
            return
        try:
            callback(message)
        except Exception:  # pragma: no cover - best effort status callback
            pass


def run_task(function, *args, **kwargs):
    task = Task(function, *args, **kwargs)
    QgsApplication.taskManager().addTask(task)
    return task


class Segmenter:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "Segmenter_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&Map Segmenter")

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        QSettings().setValue("/qgis/parallel_rendering", True)
        threadcount = QThread.idealThreadCount()
        QgsApplication.setMaxThreads(threadcount)

        self.task = None
        self._status_buffer = []
        self._log_history = deque(maxlen=50)
        self.status_emitter = StatusEmitter()
        self.status_emitter.message.connect(self._handle_status_message)
        self.model = "cnn"
        self._logged_missing_layers = False
        self.autoencoder_manager: Optional[TextureAutoencoderManager] = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("Segmenter", message)

    def log_status(self, message):
        self._emit_status_message(message, category="general")

    def worker_status(self, message):
        self._emit_status_message(message, category="worker")

    def _emit_status_message(self, message, category):
        self.status_emitter.message.emit((category, message))

    def _handle_status_message(self, payload):
        category, message = payload
        timestamp = datetime.now().strftime("%H:%M:%S")
        entry = f"[{timestamp}] {message}"
        if getattr(self, "dlg", None):
            if self._should_display_log(category, message):
                self._append_log_entry(entry)
        else:
            self._status_buffer.append((category, message, timestamp))

    def _flush_status_buffer(self):
        if not getattr(self, "dlg", None):
            return
        while self._status_buffer:
            category, message, timestamp = self._status_buffer.pop(0)
            entry = f"[{timestamp}] {message}"
            if self._should_display_log(category, message):
                self._append_log_entry(entry)

    def _should_display_log(self, category, message):
        if category == "general":
            return True
        if category == "worker":
            return bool(re.search(r"\b\d+\s*/\s*\d+\b", message))
        return False

    def _append_log_entry(self, entry):
        self._log_history.append(entry)
        if getattr(self, "dlg", None):
            lines = list(self._log_history)[::-1]
            self.dlg.inputBox.setPlainText("\n".join(lines))

    def _set_stop_enabled(self, enabled):
        dlg = getattr(self, "dlg", None)
        if not dlg:
            return
        button = getattr(dlg, "buttonStop", None)
        if button is not None:
            button.setEnabled(bool(enabled))

    def _collect_heuristics(self):
        dlg = getattr(self, "dlg", None)
        if dlg is None:
            return {"smoothness": 0.25, "speed": 0.5, "accuracy": 0.65}

        def _value(name, default=0.5):
            slider = getattr(dlg, name, None)
            if not slider:
                return default
            maximum = max(1, slider.maximum())
            return np.clip(slider.value() / maximum, 0.0, 1.0)

        return {
            "smoothness": _value("sliderSmoothness", 0.25),
            "speed": _value("sliderSpeed", 0.5),
            "accuracy": _value("sliderAccuracy", 0.65),
        }

    def _build_heuristic_overrides(self):
        heuristics = self._collect_heuristics()
        smooth = heuristics["smoothness"]
        speed = heuristics["speed"]
        accuracy = heuristics["accuracy"]

        smoothing_scale = float(np.interp(smooth, [0.0, 1.0], [0.7, 1.9]))
        tile_factor = float(np.interp(speed, [0.0, 1.0], [0.8, 1.35]))
        tile_size = int(np.clip(TILE_SIZE * tile_factor, 192, 768))

        latent_cfg = {
            "mix": float(np.interp(smooth, [0.0, 1.0], [0.35, 0.85])),
            "temperature": float(np.interp(accuracy, [0.0, 1.0], [3.5, 0.9])),
            "neighbors": int(np.round(np.interp(accuracy, [0.0, 1.0], [6, 28]))),
            "iterations": int(max(1, round(np.interp(smooth, [0.0, 1.0], [1, 4])))),
            "spatial_weight": float(np.interp(accuracy, [0.0, 1.0], [0.04, 0.16])),
            "chunk_size": int(np.round(np.interp(speed, [0.0, 1.0], [20000, 65536]))),
            "index_points": int(np.round(np.interp(speed, [0.0, 1.0], [50000, 180000]))),
            "query_batch": int(np.round(np.interp(speed, [0.0, 1.0], [12000, 60000]))),
            "hierarchy_factor": 1 if accuracy < 0.4 else 2,
            "hierarchy_passes": 1 if accuracy < 0.7 else 2,
        }

        latent_cfg["mix"] = np.clip(latent_cfg["mix"], 0.2, 0.95)

        return {
            "tile_size": tile_size,
            "smoothing_scale": smoothing_scale,
            "latent_knn": latent_cfg,
        }

    def open_feedback_link(self):
        if not getattr(self, "dlg", None):
            return
        opened = QDesktopServices.openUrl(QUrl(GITHUB_ISSUES_URL))
        if opened:
            self.log_status(f"Opening feedback page: {GITHUB_ISSUES_URL}")
        else:
            QMessageBox.warning(
                self.dlg,
                "Unable to open link",
                "Could not launch the browser. Please visit the issues page manually.",
            )

    def stop_current_task(self):
        if not self.task:
            self.log_status("No active segmentation task to cancel.")
            return
        if self.task.isCanceled():
            self.log_status("Cancellation already requested.")
            return
        try:
            task_id = self.task.taskId()
        except AttributeError:
            task_id = None
        if task_id is not None:
            QgsApplication.taskManager().cancelTask(task_id)
        self.task.cancel()
        self._set_stop_enabled(False)
        self.log_status("Cancellation requested; attempting to stop the worker immediately.")

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ":/plugins/segmenter/icon.png"
        self.add_action(
            icon_path,
            text=self.tr("Segment the map"),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&Map Segmenter"), action)
            self.iface.removeToolBarIcon(action)

    # Predict coverage map
    def predict(self):

        # Load user specified raster
        layer_name = self.dlg.inputLayer.currentText()
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if not layers:
            self.log_status("Selected layer is no longer available. Please choose another layer.")
            return
        layer = layers[0]
        if not self._is_supported_raster_layer(layer):
            self.log_status("Selected layer is not a supported 3-band GeoTIFF raster.")
            return
        assert layer.isValid(), f"Invalid raster layer! \n{layer_name}"
        raster = gdal.Open(layer.source())
        layer_array = raster.ReadAsArray()

        if self.autoencoder_manager is None:
            self.log_status("Autoencoder unavailable; please reopen the Segmenter dialog to reinitialize.")
            return
        self.autoencoder_manager.set_device(self.device)

        # Get user specified num segments
        segments_raw = (self.dlg.inputSegments.text() or "").strip()
        if not segments_raw:
            self.log_status("Please enter the desired number of segments and try again.")
            self.dlg.inputSegments.setFocus()
            return
        try:
            num_segments = int(segments_raw)
        except ValueError:
            self.log_status("Number of segments must be an integer value.")
            self.dlg.inputSegments.setFocus()
            return
        if num_segments <= 0:
            self.log_status("Number of segments must be a positive integer.")
            self.dlg.inputSegments.setFocus()
            return

        resolution_map = {
            "high": 4,
            "medium": 8,
            "low": 16,
        }

        # Get user specified resolution
        resolution_label = self.dlg.inputRes.currentText()
        resolution = resolution_map[resolution_label]
        profile_tier = (resolution_label or "low").strip().lower()

        # Set up kwargs
        if not hasattr(self, "device"):
            raise AttributeError("Segmenter instance must have a 'device' attribute set before calling predict().")
        device = self.device
        chunk_plan = recommended_chunk_plan(layer_array.shape, device, profile_tier=profile_tier)
        budget_mb = chunk_plan.budget_bytes / (1024 * 1024)
        self.log_status(
            f"Prepared chunk plan: window {chunk_plan.chunk_size}px with {chunk_plan.overlap}px overlap (using {chunk_plan.ratio * 100:.2f}% of free VRAM, ~{budget_mb:.1f} MB)."
        )

        kwargs = {
            "layer": layer,
            "canvas": self.canvas,
            "dlg": self.dlg,
            "model": self.model,
            "num_segments": num_segments,
            "resolution": resolution,
            "status_callback": self.log_status,
            "segmenter": self,
        }

        heuristic_overrides = None

        # set up args
        if self.model == "kmeans":
            func = execute_kmeans_segmentation
            args = (
                layer_array,
                num_segments,
                resolution,
                chunk_plan,
                self.worker_status,
                self.autoencoder_manager,
            )
        elif self.model == "cnn":
            heuristic_overrides = self._build_heuristic_overrides()
            heuristics = self._collect_heuristics()
            self.log_status(
                "Heuristic tuning â€” smoothness {:.2f}, speed {:.2f}, accuracy {:.2f}.".format(
                    heuristics["smoothness"], heuristics["speed"], heuristics["accuracy"]
                )
            )
            self.log_status(
                f"Adaptive overrides: tile {heuristic_overrides['tile_size']}px, smoothing x{heuristic_overrides['smoothing_scale']:.2f}."
            )
            func = execute_cnn_segmentation
            args = (
                self.load_model(resolution),
                layer_array,
                num_segments,
                chunk_plan,
                TILE_SIZE,
                device,
                self.worker_status,
                profile_tier,
                heuristic_overrides,
                self.autoencoder_manager,
            )

        self.log_status(
            f"Queued {self.model.upper()} segmentation with {num_segments} segments at {self.dlg.inputRes.currentText()} resolution."
        )

        # Run task
        self.task = run_task(func, *args, **kwargs)
        self._set_stop_enabled(True)

        # Display error if task stops running after a little bit
        if self.task.waitForFinished(1):
            self.log_status("An error occurred. Please try again.")

    # Load model from disk
    def load_model(self, model_name):
        # Load model into bytes object
        model_path = os.path.join(self.plugin_dir, f"models/model_{model_name}.pth")
        with open(model_path, "rb") as f:
            model_bytes = BytesIO(f.read())

        # Load torchscript model
        model = torch.jit.load(model_bytes)
        model.eval().to(self.device)

        return model

    # Process user input box
    def submit(self):
        return

    #  Display models in dropdown
    def render_models(self):
        model_list = ["K-Means", "CNN"]
        self.dlg.inputLoadModel.clear()
        for model in model_list:
            self.dlg.inputLoadModel.addItem(model)
        default_model = "CNN"
        index = self.dlg.inputLoadModel.findText(default_model)
        if index >= 0:
            self.dlg.inputLoadModel.setCurrentIndex(index)
        self.set_model()

    # Display layers in dropdown
    def render_layers(self):
        project_layers = QgsProject.instance().mapLayers().values()
        raster_layers = [
            layer
            for layer in project_layers
            if isinstance(layer, QgsRasterLayer) and self._is_supported_raster_layer(layer)
        ]
        raster_layers.sort(key=lambda lyr: lyr.name().lower())

        current = self.dlg.inputLayer.currentText()
        self.dlg.inputLayer.clear()
        if not raster_layers:
            if not self._logged_missing_layers:
                self.log_status("No supported 3-band GeoTIFF rasters detected in the project.")
                self._logged_missing_layers = True
            return

        self._logged_missing_layers = False
        for layer in raster_layers:
            self.dlg.inputLayer.addItem(layer.name())

        if current:
            index = self.dlg.inputLayer.findText(current)
            if index >= 0:
                self.dlg.inputLayer.setCurrentIndex(index)

    # Display resolutions in dropdown
    def render_resolutions(self):
        res_list = ["low", "medium", "high"]
        self.dlg.inputRes.clear()
        for res in res_list:
            self.dlg.inputRes.addItem(str(res))
        default_res = "low"
        index = self.dlg.inputRes.findText(default_res)
        if index >= 0:
            self.dlg.inputRes.setCurrentIndex(index)

    # Set model based on selected dropdown
    def set_model(self):
        model = self.dlg.inputLoadModel.currentText()
        if model == "K-Means":
            self.model = "kmeans"
        elif model == "CNN":
            self.model = "cnn"

    def _is_supported_raster_layer(self, layer):
        if not isinstance(layer, QgsRasterLayer):
            return False
        try:
            band_count = layer.bandCount()
        except Exception:
            return False
        if band_count != 3:
            return False
        provider = layer.dataProvider()
        if not provider:
            return False
        if provider.name().lower() != "gdal":
            return False
        source = layer.source().split("|")[0]
        _, ext = os.path.splitext(source)
        if ext.lower() not in SUPPORTED_RASTER_EXTENSIONS:
            return False
        return True

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = SegmenterDialog()
            self.canvas = self.iface.mapCanvas()

            # Set device (CUDA, CPU)
            if torch.cuda.is_available(): # Cuda
                self.device = torch.device("cuda")
            elif torch.backends.mps.is_available(): # Multi-Process Service
                self.device = torch.device("mps")
            else: # CPU
                self.device = torch.device("cpu")

            cache_dir = default_autoencoder_path(self.plugin_dir)
            self.autoencoder_manager = TextureAutoencoderManager(cache_dir)
            self.autoencoder_manager.set_device(self.device)

            settings, profiled = load_or_profile_settings(
                self.plugin_dir, self.device, self.log_status
            )
            if profiled:
                self.log_status(
                    f"Adaptive profiling complete (safety={settings.safety_factor}, prefetch={settings.prefetch_depth})."
                )
            else:
                self.log_status(
                    f"Loaded cached adaptive profile (safety={settings.safety_factor}, prefetch={settings.prefetch_depth})."
                )

            # Populate drop down menus
            self.render_models()
            self.render_layers()
            self.render_resolutions()

            # Set gpu message
            gpu_msg = "GPU available."
            if self.device == torch.device("cpu"):
                gpu_msg = "GPU not available. Using CPU instead."

            self._log_history.clear()
            self.dlg.inputBox.clear()
            self._flush_status_buffer()
            self.log_status(gpu_msg)

            # Attach inputs
            self.dlg.inputBox.textChanged.connect(self.submit)
            self.dlg.buttonPredict.clicked.connect(self.predict)
            self.dlg.buttonFeedback.clicked.connect(self.open_feedback_link)
            self.dlg.buttonStop.clicked.connect(self.stop_current_task)
            self.dlg.inputLoadModel.currentIndexChanged.connect(self.set_model)
            self.dlg.inputLoadModel.highlighted.connect(self.render_layers)
            self._set_stop_enabled(False)

            # Render logo
            img_path = os.path.join(self.plugin_dir, "logo.png")
            pix = QPixmap(img_path)
            self.dlg.imageLarge.setPixmap(pix)

        # show the dialog
        self.render_layers()
        self.dlg.show()
